"""
This file was autogenerated by pybind11-stubs, and then modified manually to fix
some errors.
"""
from __future__ import annotations
import numpy
import numpy.typing as npt
import typing
__all__ = ['DataFrame', 'load']
class DataFrame:
    def __call__(self, arg0: str) -> npt.NDArray[numpy.float64] | npt.NDArray[numpy.int64] | npt.NDArray[numpy.float32] | npt.NDArray[numpy.uint64] | npt.NDArray[numpy.complex128] | npt.NDArray[numpy.complex64]:
        ...
    def __getitem__(self, col_idx: int) -> npt.NDArray[numpy.float64] | npt.NDArray[numpy.int64] | npt.NDArray[numpy.float32] | npt.NDArray[numpy.uint64] | npt.NDArray[numpy.complex128] | npt.NDArray[numpy.complex64]:
        ...
    def __getstate__(self) -> tuple[npt.NDArray[numpy.float64 | numpy.complex64 | numpy.complex128 | numpy.int64 | numpy.uint64 | numpy.float32], dict[int, dict[int, str]], list[str]]:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, data: list[list[float | complex | complex | int | int | int | int | float]], labels: list[str] | None = None) -> None:
        """
        Parameters
        ----------
        data : list or list[list], optional
        labels : list[str], optional
        """
    def __repr__(self) -> str:
        ...
    def __setitem__(self, arg0: int, arg1: npt.NDArray[numpy.float64] | npt.NDArray[numpy.int64] | npt.NDArray[numpy.float32] | npt.NDArray[numpy.uint64] | npt.NDArray[numpy.complex128] | npt.NDArray[numpy.complex64]) -> None:
        ...
    def __setstate__(self, arg0: tuple[npt.NDArray[numpy.float64 | numpy.complex64 | numpy.complex128 | numpy.int64 | numpy.uint64 | numpy.float32], dict[int, dict[int, str]], list[str]]) -> None:
        ...
    def append_column(self, col: npt.NDArray[numpy.float64] | npt.NDArray[numpy.int64] | npt.NDArray[numpy.float32] | npt.NDArray[numpy.uint64] | npt.NDArray[numpy.complex128] | npt.NDArray[numpy.complex64], label: str | None = None) -> None:
        """
        Append a column to the DataFrame. Must have a correct amount of
        rows.
        
        Parameters
        ----------
        col : numpy.typing.NDArray
            Must be a column vector i.e. shape=(x, 1)
        label : Optional[str]
        """
    def append_row(self, row: list[float | complex | complex | int | int | int | int | float]) -> None:
        """
        Append a row to the DataFrame. Must have a correct amount of
        columns and the data types must match the current column dtypes.
        
        Parameters
        ----------
        row : list or list[list]
            A list with len 3 has 3 columns.
        """
    def get_map(self, idx: int) -> dict[int, str]:
        """
        Get the integer label map for some column (if there is a mapping).
        
        Parameters
        ----------
        idx : int
            The index of the column from which you want to get a map.
        
        Returns
        -------
        col_cat_map : dict[int, str]
        """
    def insert_column(self, col: npt.NDArray[numpy.float64] | npt.NDArray[numpy.int64] | npt.NDArray[numpy.float32] | npt.NDArray[numpy.uint64] | npt.NDArray[numpy.complex128] | npt.NDArray[numpy.complex64], idx: int, label: str | None = None) -> None:
        """
        Insert a column into the DataFrame.
        
        Parameters
        ----------
        col : np.typing.NDArray
        idx : unsigned int
        label : string, optional
        """
    def insert_row(self, row: list[float | complex | complex | int | int | int | int | float], idx: int) -> None:
        """
        Insert a row into the DataFrame.
        
        Parameters
        ----------
        row : list
        idx : unsigned int
        """
    def set_map(self, idx: int, map: dict[int, str]) -> None:
        """
        Set a integer-string mapping for a specific column.
        
        Parameters
        ----------
        idx : unsigned int
        map : dict[int, str]
        """
    def summarize(self) -> None:
        """
        Print a summary of the DataFrame.
        """
    def view(self, idx: int) -> npt.NDArray[numpy.float64] | npt.NDArray[numpy.int64] | npt.NDArray[numpy.float32] | npt.NDArray[numpy.uint64] | npt.NDArray[numpy.complex128] | npt.NDArray[numpy.complex64]:
        """
        Get a view into a column. This is much faster than indexing the dataframe
        because the column memory is not copied. This does mean however that the
        returned Numpy array is read-only.
        
        Parameters
        ----------
        idx : unsigned int
        
        Returns
        -------
        col : np.typing.NDArray
            A read-only numpy array.
        """
    @property
    def cat_map(self) -> dict[int, dict[int, str]]:
        """
        Get all integer label maps for all columns.
        
        Returns
        -------
        all_cat_maps : dict[int, dict[int, str]]
            Where the outer dict maps column idx to category maps.
        """
    @cat_map.setter
    def cat_map(self, arg1: dict[int, dict[int, str]]) -> None:
        ...
    @property
    def column_labels(self) -> list[str] | None:
        """
        The labels for each column if they are present. When setting the
        labels, there must be a label for each column.
        
        Returns
        -------
        column_labels : list[str]
        """
    @column_labels.setter
    def column_labels(self, arg1: list[str]) -> None:
        ...
    @property
    def shape(self) -> tuple[int, int]:
        """
        Number of rows and columns in the DataFrame.
        
        Returns
        -------
        shape : tuple[int, int]
        """
@typing.overload
def load(filepath: str, dataframe: DataFrame, header: bool | None = None, columns: list[int] | None = None, col_types: list[typing.Callable[[str], float | complex | complex | int | int | int | int | float]] | None = None, newline_delimiter: str | None = None, column_delimiter: str | None = None) -> list[str]:
    """
    Load a CSV file into a DataFrame object.
    
    Parameters
    ----------
    filepath : str
    dataframe : numoop.DataFrame, optional
    header : bool
        Whether the CSV file has a header.
    columns : list[int], optional
        What specific columns should be loaded from the file.
    col_types : list[Callable[Any, str]]
        A list of functions to be used when converting strings to numeric types.
    newline_delimiter : str
    column_delimiter : str
    
    Returns
    -------
    df : numoop.DataFrame
    types : list[str]
        The column types that were autodetected when loading the CSV.
    """
@typing.overload
def load(filepath: str, header: bool | None = None, columns: list[int] | None = None, col_types: list[typing.Callable[[str], float | complex | complex | int | int | int | int | float]] | None = None, newline_delimiter: str | None = None, column_delimiter: str | None = None) -> tuple[list[str], DataFrame]:
    """
    Load a CSV into a new DataFrame
    """
__version__: str = 'dev'
